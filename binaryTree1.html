<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        function Node(data, left, right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }
        // function setTree() {
        //     var root = new Node(1, null, null);
        //     var node1 = new Node(2, null, null);
        //     var node2 = new Node(3, null, null);
        //     var node3 = new Node(4, null, null);
        //     var node4 = new Node(5, null, null);
        //     var node5 = new Node(6, null, null);
        //     var node6 = new Node(7, null, null);
        //      var node7 = new Node(8, null, null);
        //     var node8 = new Node(9, null, null);
        //     root.left = node1;
        //     root.right = node2;
        //     node1.left = node3;
        //     node1.right = node4;
        //     node2.left = node5;
        //     node2.right = node6;
        //     node3.left = node7;
        //     node3.right = node8;
        //     return root;
        // }

        // console.log(setTree())
        // var tree = setTree();
        // 更少的空间去存储一个二叉树。
        
        // function pre(node) {
        //     if (node == null) {
        //         return ;
        //     }
            
        //     pre(node.left);
            
        //     pre(node.right);
        //     console.log(node.data);
            
        // }
        // pre(tree);
        


        function perMid(pre, mid) {
            if(pre.length == 0 || mid.length == 0) {
                return null;
            }
            if (pre.length != mid.length) {
                throw Error('参数不正确')
            }
            // 根节点数据
            var rootData = pre[0];
            // 根节点在中序遍历中的位置
            var midRootIndex = mid.indexOf(rootData);
            // 左子树中序遍历
            var leftMid = mid.slice(0, midRootIndex);
            // 右子树中序遍历
            var rightMid = mid.slice(midRootIndex + 1);
            // 左子树前序遍历
            var leftPre = pre.slice(1, leftMid.length + 1);
             // 右子树前序遍历
            var rightPre = pre.slice(leftMid.length + 1);
            // 左子树还原
            var left = perMid(leftPre, leftMid);
            // 右子树还原
            var right = perMid(rightPre, rightMid);
            
            // 最终二叉树
            var node = new Node(pre[0], left, right);
            return node;
        }
        
        var pre = [1,2,4,5,3,6];
        var mid = [4,2,5,1,3,6];
        console.log(perMid(pre,mid));
        var aft = [4,5,2,6,3,1];
        console.log(afterMid(aft, mid))

        function afterMid(aft, mid) {
            if(aft.length == 0 || mid.length == 0) {
                return null;
            }
            if (aft.length != mid.length) {
                throw Error('参数不正确')
            }
            // 根节点数据
            var rootData = aft[aft.length - 1];
            // 根节点在中序遍历中的位置
            var midRootIndex = mid.indexOf(rootData);
            // 左子树中序遍历
            var leftMid = mid.slice(0, midRootIndex);
            // 右子树中序遍历
            var rightMid = mid.slice(midRootIndex + 1);
            // 左子树后序遍历
            var leftAft = aft.slice(0, leftMid.length);
             // 右子树后序遍历
            var rightaft = aft.slice(leftMid.length, aft.length - 1);
            // 左子树还原
            var left = afterMid(leftAft, leftMid);
            // 右子树还原
            var right = afterMid(rightaft, rightMid);
            
            // 最终二叉树
            var node = new Node(aft[aft.length - 1], left, right);
            return node;
        }



    </script>
</body>
</html>